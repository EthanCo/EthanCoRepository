# Android插件化: 从入门到放弃 #
## 入门知识 ##
要想完全明白插件化技术，首先需要了解Android系统的底层实现

- Binder
	- 可以认为是一个中介者模式，在客户端和服务器端之间，Binder起到中介的作用
	- 要实现四大组件的插件化，就需要在Binder上做修改。Binder服务端的内容没办法修改，只能改客户端的代码。四大组件各个组件的客户端都不太一样。  
	- 学习Binder最好的方式是AIDL，可以读到很多关于AIDL的资料，通过定制一个aidl文件自动生成一个Java类，研究一下这个Java类的每个方法和变量，然后反过来看四大组件，其实都是跟AIDL差不多的方式。
- App打包流程
	- 执行一次打包操作，中途经理了资源打包、dex生成、签名等过程。其中最重要的就是资源的打包，即AAPT这一步，如果宿主和插件的资源id冲突，一种解决办法就是在这里做修改。
- App安装流程
	- 熟悉安装流程不仅对插件化有帮助，在遇到安装bug的时候也非常重要。  
	- 手机安装App的时候，经常会有下载异常，提示资源包不能解析，这是需要知道安装App的这段代码在什么地方，这只是第一步  
	- 第二步需要知道，App下载到本地后，具体要做哪些事情。手机有些目录不能访问，App下载到本地后，放在哪个目录下，然后会生成哪些文件
	- 插件化有个增量更新的概念，如何下载一个增量包，从本地具体哪个位置取出一个包，这个包的具体命名规则是什么，等等，这些细节必须要清楚明白。
- App启动过程
	- Activity启动有几种方式? 一种是写一个startActivity，第二种是点击手机App，通过手机系统里的Launcher机制，启动App里默认的Activity。他们的启动原理是什么呢 ? 另外，启动的时候，main函数在哪里 ? 这个main函数的位置很重要，我们可以对它所在的类做修改，从而实现插件化。
- 资源加载机制
	- 第五点更重要，做Android插件化需要控制两个地方。首先是插件Dex的加载，如何把插件Dex中的类加载到内存 ? 另外是资源加载的问题。插件可能是apk也可能是so格式，不管是哪种，都不会生成R.id，从而没有办法使用。这个问题由好几种解决方法
		- 重写Context的getAssert、getResource之类的方法，偷换概念，让插件读取插件里的资源，但缺点就是宿主和插件的资源id会冲突，需要重写AAPT  
		- 另一种是重写AMS中保存的插件列表，从而让宿主和插件分别取加载各自的资源而不会冲突。  
		- 第三种，就是打包后，执行一种脚本，修改生成包中的资源ID
- Gradle
	- 在实时插件后，如何解决不同插件的开发人员的工作区问题。  
		- 比如，插件1和插件2需要分别下载那些代码，如何独立运行 ? 就像机票和火车票，如何只运行自己的插件，而不运行别人的插件 ? 这是协同工作的问题。  火车票和机票，这两个Android团队的各自工作区是不一样的，这时候就要用到Gradle脚本了，各个项目分别有各自的仓库，有各自不同的打包脚本，只需要把自己的插件和宿主项目打包运行起来，而不用引用其他插件，还有更厉害的是，也可以把自己的插件当做一个App来打包并运行。  

## 技术流派 ##

### 动态替换 ###
动态替换，也就是Hook，可以在不同层次进行Hook，从而动态代理也分为若干小流派。
  
1. 可以直接在Activity中做Hook，重写getAssert的几个方法，从而使用自己的ResourceManager和AssertPath  
2. 也可以在更抽象的层面，也就是startActivity方法的位置做Hook，涉及的类包括ActivityThread、Instrumentation等  
3. 最高层次则是在AMS上做修改，也就是张勇的解决方案，这里需要修改的类非常多，AMS、PMS等都需要改动。

总之，在越抽象的层次上做Hook，需要做的改动就越大都会但好处就是更加灵活了。没有哪一个方法更好，一切看你的选择。    

### 静态代理 ###
静态代理，这是任玉刚的框架采用的思路。写一个PluginActivity继承自Activity基类，把Activity基类里面涉及生命周期的方法全都重写一遍，插件中的Activity是没有生命周期的，所以要让插件中的Activity都继承自PluginActivity，这样就有生命周期了。  
### Dex合并 ###
Dex合并，就是Android热修复的思想。原生APK自带的Dex是通过PathClassLoader来加载的，而插件Dex则是通过DexClassLoader来加载的。但是有一个顺序问题，是由Davlik的机制决定的，如果宿主Dex和插件Dex都有一个相同命名空间的类的方法，那么先加载哪个Dex，哪个Dex中的这个类的方法将会占山为王，后面其他同名方法都替换了。所以，AndFix热修复就是优先加载插件中的Dex，从而实现热修复。由于热修复的插件包通常只包含一个类的方法，体量很小，和正常的插件不是一个数量级的，所以只称为热修复补丁包，而不是插件。  

## 技术周边 ##
### AAPT ###
	
资源冲突，就是说默认App应用、插件里的资源和数据接口冲突，如果不引用这个资源，相安无事。很多时候就算有冲突也无所谓，问题就出在插件引用资源的时候有冲突了，无法解决，怎么办 ? 那就要立刻改写App。有一个关于打包的App，可以加当前的前缀，改成你想要的。比如，火车票和酒店分别取名，这样就可以指定前缀、打包，插入一个模块，资源的前缀都不一样，小米也承认，会占用0x11这个前缀，这是需要关注的一个点。

### 增量更新 ###
360目前最牛逼的地方是，把所有数据跟前一个版本差，产生增量的数据。当然他们也更新了插件化。360的刘存栋做了一个增量更新的框架。可以在后台服务器把两个版本的Android app做拆分，然后把增量包下载到本地，再和本地进行合并，提供一个STK，在和在一起，这就是增量更新。  
### 插件管理平台 ###
要管理每个版本的差异、每个插件最低数据的版本号  

## 最后 ##
最后是内功的修炼，通读一遍上面列出来的基础知识，然后再去做App应用，你会清楚知道动态广播、动态广播具体什么时候用，什么时候可能会出bug。AIDL可能会很少使用，但真正做设计和实现的时候，这个基本功就非常重要了。所以插件化只是一门技术，你最应该关注的是其背后的本质，也就是内功的修炼。 